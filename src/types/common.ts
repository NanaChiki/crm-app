/**
 * 🌐 共通型定義システム - Common Types for 50+ Users
 *
 * 【なぜ「共通型」が必要なのか？】
 * 1. 型の重複を避けてメンテナンス性向上
 * 2. 一貫したユーザー体験の提供
 * 3. エラーハンドリングやローディング状態の統一
 * 4. 開発チーム間での設計思想の統一
 * 5. 50代ユーザー向けの配慮を全画面で統一
 */

// =============================================================================
// 🔄 ローディング・状態管理用の型定義
// =============================================================================

/**
 * LoadingState型 - アプリ全体のローディング・エラー状態管理
 *
 * 【なぜ共通型にするのか？】
 * - 顧客管理、サービス履歴、検索機能など全ての非同期処理で使用
 * - 一貫したローディング表示でユーザー体験を統一
 * - 50代ユーザーに安心感を与える明確な状態表示
 *
 * 【50代ユーザー配慮】
 * - loading: 「処理中です...」等の分かりやすいメッセージ表示
 * - error: 技術用語を避けた親切なエラーメッセージ
 * - success: 操作完了の明確なフィードバック
 *
 * 【使用例】
 * - 顧客一覧読み込み中
 * - サービス履歴保存中
 * - 検索処理中
 */
export interface LoadingState {
  /** 処理中フラグ
   * 【true時の表示例】「データを読み込んでいます...」「保存しています...」 */
  isLoading: boolean;

  /** エラー状態
   * 【null以外時】エラーメッセージを表示してユーザーに状況を説明 */
  error: string | null;

  /** 成功状態（任意）
   * 【50代配慮】操作完了時の明確なフィードバック用 */
  isSuccess?: boolean;
}

// =============================================================================
// 📡 API通信用の統一型定義
// =============================================================================

/**
 * ApiResponse<T>型 - API呼び出しの統一レスポンス形式
 *
 * 【ジェネリクス<T>を使う理由】
 * - Customer、ServiceRecord、検索結果など様々なデータ型に対応
 * - 型安全性を保ちながら汎用的に使用可能
 * - コードの重複を避けて保守性向上
 *
 * 【統一する利点】
 * - フロントエンド・バックエンド間でのデータ形式統一
 * - エラーハンドリングの一貫性
 * - 50代ユーザー向けメッセージの標準化
 *
 * 【使用例】
 * - ApiResponse<Customer[]> - 顧客一覧取得
 * - ApiResponse<ServiceRecord> - サービス履歴作成
 * - ApiResponse<null> - 削除処理（データなし）
 */
export interface ApiResponse<T> {
  /** レスポンスデータ
   * 【ジェネリクス】型安全にあらゆるデータ型を格納 */
  data: T;

  /** 処理成功フラグ
   * 【true】正常処理、【false】何らかのエラー発生 */
  success: boolean;

  /** メッセージ（任意）
   * 【50代配慮】「保存が完了しました」「エラーが発生しました」等 */
  message?: string;

  /** エラーコード（任意）
   * 【開発用】デバッグやログ記録用、ユーザーには直接表示しない */
  errorCode?: string;
}

// =============================================================================
// ⚠️ エラーハンドリング用の型定義
// =============================================================================

/**
 * AppError型 - アプリ全体で統一されたエラー情報
 *
 * 【50代ユーザー向けエラー設計】
 * - 技術用語を避けた分かりやすい日本語メッセージ
 * - 解決方法を含む親切な説明
 * - パニックを避ける安心感のある表現
 *
 * 【統一する理由】
 * - 全画面で一貫したエラー表示
 * - サポート時の問題特定を容易にする
 * - ユーザーが自力で解決できる情報提供
 */
export interface AppError {
  /** エラーメッセージ（50代向け分かりやすい表現）
   * 【例】「ネットワークに接続できませんでした」
   * 【避ける例】「HTTP 500 Internal Server Error」 */
  message: string;

  /** エラーの種類
   * 【network】「インターネット接続を確認してください」
   * 【validation】「入力内容に不備があります」
   * 【permission】「この操作を行う権限がありません」
   * 【server】「一時的な問題が発生しています」 */
  type: 'network' | 'validation' | 'permission' | 'server';

  /** 解決方法の提案（50代向けの具体的な手順）
   * 【例】「ページを再読み込みしてもう一度お試しください」 */
  suggestion?: string;

  /** 技術的詳細（開発・サポート用）
   * 【ユーザーには表示しない】問題解決時の参考情報 */
  technical?: string;
}

// =============================================================================
// 📝 フォーム管理用の型定義
// =============================================================================

/**
 * FormState<T>型 - フォーム送信状態の統一管理
 *
 * 【ジェネリクス<T>の活用】
 * - CreateCustomerInput、UpdateServiceRecordInput等あらゆるフォームに対応
 * - 型安全なフォームデータ管理
 * - バリデーション結果もタイプセーフに管理
 *
 * 【50代ユーザー配慮】
 * - 送信中の明確な状態表示
 * - エラー時の分かりやすいメッセージ
 * - 成功時の安心できるフィードバック
 *
 * 【使用例】
 * - FormState<CreateCustomerInput> - 新規顧客登録フォーム
 * - FormState<UpdateServiceRecordInput> - サービス履歴編集フォーム
 */
export interface FormState<T> {
  /** フォームデータ
   * 【ジェネリクス】各フォーム専用の型安全なデータ管理 */
  data: T;

  /** 送信中フラグ
   * 【true時】「保存しています...」表示、ボタン無効化 */
  isSubmitting: boolean;

  /** フォーム送信後の状態 */
  submitStatus: 'idle' | 'success' | 'error';

  /** バリデーションエラー（フィールド別）
   * 【型安全】フォームの各フィールドに対応したエラー管理 */
  errors: Partial<Record<keyof T, string>>;

  /** 全体エラーメッセージ
   * 【50代配慮】「入力内容を確認してください」等の優しい表現 */
  generalError?: string;
}

/**
 * ValidationError型 - フォームバリデーションエラーの詳細
 *
 * 【50代向け設計】
 * - 何が問題なのか明確に説明
 * - どう修正すれば良いか具体的な指示
 * - 威圧的でない優しい表現
 */
export interface ValidationError {
  /** エラーのあるフィールド名 */
  field: string;

  /** エラーメッセージ（50代向け親切な表現）
   * 【例】「会社名を入力してください」
   * 【避ける例】「companyName is required」 */
  message: string;

  /** エラーの種類 */
  type: 'required' | 'minLength' | 'length' | 'custom';

  /** 修正方法の説明（任意）
   * 【例】「電話番号は「090-1234-5678」の形式で入力してください」 */
  hint?: string;
}

// =============================================================================
// 🔍 検索・フィルタリング用の共通型定義
// =============================================================================

/**
 * SearchFilters型 - 全検索機能で共通使用するフィルター
 *
 * 【共通化する理由】
 * - 顧客検索、サービス履歴検索で統一されたUX
 * - 検索機能の開発効率向上
 * - 50代ユーザーにとって覚えやすい統一操作
 *
 * 【50代向け配慮】
 * - シンプルで直感的な検索条件
 * - 複雑な条件は段階的に表示
 * - クリアボタンで簡単リセット
 */
export interface SearchFilters {
  /** キーワード検索（全文検索）
   * 【50代配慮】「何でも入力してください」的な使いやすさ */
  keyword?: string;

  /** 期間フィルター（開始日）
   * 【日付選択】カレンダーUIで直感的に選択 */
  startDate?: Date;

  /** 期間フィルター（終了日）
   * 【日付選択】カレンダーUIで直感的に選択 */
  endDate?: Date;

  /** ステータスフィルター
   * 【選択式】ドロップダウンやラジオボタンで明確に選択 */
  status?: string;

  /** カスタムフィルター（拡張用）
   * 【将来対応】画面固有の検索条件を追加可能 */
  customFilters?: Record<string, any>;
}

// =============================================================================
// 📄 ページネーション用の型定義
// =============================================================================

/**
 * PaginationState型 - 一覧表示のページング機能
 *
 * 【50代ユーザー向け設計】
 * - 「前へ」「次へ」ボタンは大きく分かりやすく
 * - 現在位置を明確に表示「3ページ目 / 全10ページ」
 * - 1ページの件数は適切な数（多すぎると疲れる）
 *
 * 【統一する利点】
 * - 全ての一覧画面で同じ操作感
 * - ページネーションコンポーネントの再利用
 * - パフォーマンス最適化の一元管理
 */

export interface PaginationState {
  /** 現在のページ番号（1から開始）
   * 【50代配慮】0ベースではなく1ベースで自然な数え方 */
  currentPage: number;

  /** 1ページあたりの表示件数
   * 【デフォルト推奨】10-20件（50代には丁度良い件数） */
  itemsPerPage: number;

  /** 総アイテム数
   * 【表示例】「全123件中 1-10件を表示」 */
  totalItems: number;

  /** 総ページ数（計算値）
   * 【Math.ceil(totalItems / itemsPerPage)で算出】 */
  totalPages: number;

  /** 前のページがあるか
   * 【UI制御】「前へ」ボタンの有効/無効切り替え */
  hasPreviousPage: boolean;

  /** 次のページがあるか
   * 【UI制御】「次へ」ボタンの有効/無効切り替え */
  hasNextPage: boolean;
}

// =============================================================================
// 📊 ソート・並び替え用の型定義
// =============================================================================

/**
 * SortOrder型 - 一覧表示の並び替え機能
 *
 * 【50代向けシンプル設計】
 * - 昇順/降順の概念を分かりやすく表現
 * - 「新しい順」「古い順」「あいうえお順」等の自然な表現
 * - ワンクリックで並び替え可能
 */
export interface SortOrder {
  /** ソート対象のフィールド
   * 【例】'createdAt', 'companyName', 'amount' */
  field: string;

  /** ソート方向
   * 【asc】昇順「あいうえお順」「古い順」「安い順」
   * 【desc】降順「んをわ順」「新しい順」「高い順」 */
  direction: 'asc' | 'desc';

  /** ソート項目の表示名（50代向け分かりやすい表現）
   * 【例】field: 'createdAt' → label: '登録日時' */
  label: string;
}

// =============================================================================
// 🔔 通知メッセージ用の型定義
// =============================================================================

/**
 * SnackbarMessage型 - ユーザーへの通知メッセージ（50代向け親切設計）
 *
 * 【50代ユーザーへの配慮】
 * - 成功・警告・エラーを色とアイコンで直感的に表現
 * - メッセージは丁寧で安心感のある日本語
 * - 自動で消えるが、ユーザーが手動で閉じることも可能
 * - 重要な情報は確実に伝わるよう工夫
 */
export interface SnackbarMessage {
  /** 通知メッセージ（50代向け親切な表現）
   * 【成功例】「顧客情報を保存しました」
   * 【エラー例】「保存に失敗しました。もう一度お試しください」 */
  message: string;

  /** メッセージの種類（色とアイコンに影響）
   * 【success】緑色、チェックアイコン「✓ 完了しました」
   * 【error】赤色、警告アイコン「⚠ エラーが発生しました」
   * 【warning】黄色、注意アイコン「⚠ ご注意ください」
   * 【info】青色、情報アイコン「ℹ お知らせ」 */
  severity: 'success' | 'error' | 'warning' | 'info';

  /** 表示時間（ミリ秒）
   * 【デフォルト】4000ms（4秒）- 50代が読むのに十分な時間 */
  duration?: number;

  /** アクション付きメッセージ（任意）
   * 【例】「元に戻す」「詳細を見る」ボタンを追加 */
  action?: {
    label: string;
    onClick: () => void;
  };

  /** 一意識別子（重複防止用）
   * 【システム用】同じメッセージの重複表示を防ぐ */
  id?: string;
}

// =============================================================================
// 🎯 型定義の使用例とベストプラクティス
// =============================================================================

/**
 * 【使用例1: 顧客管理画面での活用】
 *
 * // ページ全体の状態管理
 * const [loadingState, setLoadingState] = useState<LoadingState>({
 *   isLoading: false,
 *   error: null,
 *   success: false
 * });
 *
 * // 顧客作成フォーム
 * const [formState, setFormState] = useState<FormState<CreateCustomerInput>>({
 *   data: { companyName: '' },
 *   isSubmitting: false,
 *   submitStatus: 'idle',
 *   errors: {}
 * });
 *
 * // 検索機能
 * const [searchFilters, setSearchFilters] = useState<SearchFilters>({
 *   keyword: '',
 *   startDate: undefined,
 *   endDate: undefined
 * });
 *
 * // ページネーション
 * const [pagination, setPagination] = useState<PaginationState>({
 *   currentPage: 1,
 *   itemsPerPage: 10,
 *   totalItems: 0,
 *   totalPages: 0,
 *   hasPrevious: false,
 *   hasNext: false
 * });
 */

/**
 * 【使用例2: API呼び出しでの統一的なエラーハンドリング】
 *
 * // API関数
 * async function fetchCustomers(): Promise<ApiResponse<Customer[]>> {
 *   try {
 *     const response = await api.get('/customers');
 *     return {
 *       data: response.data,
 *       success: true,
 *       message: '顧客一覧を取得しました'
 *     };
 *   } catch (error) {
 *     return {
 *       data: [],
 *       success: false,
 *       message: 'データの取得に失敗しました',
 *       errorCode: 'FETCH_CUSTOMERS_ERROR'
 *     };
 *   }
 * }
 *
 * // エラーハンドリング
 * function handleApiError(error: AppError): void {
 *   const message: SnackbarMessage = {
 *     message: error.message,
 *     severity: 'error',
 *     duration: 6000, // エラーは長めに表示
 *     action: error.suggestion ? {
 *       label: '解決方法を見る',
 *       onClick: () => showErrorHelp(error.suggestion!)
 *     } : undefined
 *   };
 *   showSnackbar(message);
 * }
 */
